.TH ponscripter-syntax 7
.
.\" This currently doesn't format well with WoMan.
.\" Problems: `.IP "" n', `\(dq'
.
.SH NAME
ponscripter-syntax \- description of Ponscripter syntax
.
.SH DESCRIPTION
.
This page documents the syntax of Ponscripter scripts.
.
See
.BR ponscripter (7)
for an overview of available documentation.
.
.PP
Note that this cannot be considered NScripter documentation.
.
NScripter itself is largely unspecified.
.
Ponscripter's implementation is ultimately based on observation and
documentation rather than on reverse-engineering as such: it
inevitably adopts different parsing strategies, and is significantly
more liberal in what it accepts.
.
Not all differences are described below.
.
With this disclaimer out of the way: the documentation.
.
.SS Fundamentals
Scripts are line-based.
.
There are two types of line: commands and text.
.
These have little in common, and will be treated separately in what
follows.
.
.PP
A
.BR "text line"
begins with the text delimiter, which is ^ in native scripts and \` in
legacy scripts.
.
All other lines are
.BR "command lines" ,
unless they begin with a number, a character outside the ASCII range,
or a character in the set
.BR [@\e/%?$[(!#,\(dq] ,
in which case they are assumed to be unmarked text lines.
.
Such lines are valid if they contain
.I only
!-commands; otherwise a
warning is issued, and the behaviour is undefined.
.
.PP
(Unmarked text is a historical accident, and will probably be removed
at some point in the future.
.
It derives from NScripter, where traditionally there was no
intersection between printable characters and command characters; the
\` text marker was introduced in ONScripter as a means of supporting
English text, and replaced in Ponscripter with ^ to free up \` for
other uses.
.
NScripter has subsequently introduced > as its own `English text'
marker, but the associated semantics are useless, and I shall say no
more of this.)
.
.SS Context in command lines
.
NScripter is a context-sensitive language.
.
Each parameter to a command is parsed differently based on the type of
that parameter.
.
The major types are
.BR string \ and \ integer ,
with labels and barewords being special cases of string parameters.
.
.PP
String expressions do not merely have a different type from integer
expressions, as in other languages: they have a distinct syntax.
.
Some string expressions can be parsed as integer expressions, but then
leave code unparsed that will cause a syntax error when it is reached.
.
It is therefore impossible, in the general case, to parse a line of
code unless it is known in advance what context each parameter is
using.
.
.PP
For example, given the following definitions:
.IP "" 2
numalias foo, 100
.br
stralias foo, ^bar^
.PP
the constant `foo' would have the value 100 in integer context, but
would have the value `bar' in string context.
.
(In label context, e.g. as the parameter to a
.BR goto ,
it would refer to the label `*bar'.)
.
.PP
See the next section for more on constants, and `Expression syntax'
below for details of the syntax accepted in each context.
.
.SS Lexical categories
.
The following broad lexical categories are used in command lines
(parenthesised names are used in syntax descriptions below):
.
.TP 2
.B Comments
are introduced with a semicolon, and last to the end of the line.
.
.TP 2
.BR Barewords \ (\fIbareword\fR)
have the same syntax as identifiers in most programming languages: the
first character must be in the set
.BR [A-Za-z_] ,
and the remainder must be in the set
.BR [A-Za-z0-9_] .
.
.IP "" 2
A bareword at the start of a line, or immediately following a colon,
is assumed to be a command.
.
Otherwise their interpretation is context-sensitive.
.
.IP \(bu
If an alias exists of the desired type (a
.BR numalias " in number context, or a " stralias
in string context) then the bareword acts as a constant, and the value
of the alias is substituted.
.
.IP \(bu
In string context where no stralias exists, the bareword itself is
treated as a string; it will be transformed to lower case and
substituted directly.
.
.IP \(bu
In number context where no numalias exists, a warning is issued and 0 is
substituted.
.
.IP \(bu
Some commands, such as
.BR rmenu ", " ld ", and " systemcall ,
look for barewords directly for certain parameters; in these cases
aliases are not resolved.
.
.TP 2
.BR String\ literals \ (\fIstring_lit\fR)
are formed in two ways.
.
They may be enclosed in regular double quotes, or in pairs of the text
delimiter (^ in native scripts, \` in legacy scripts).
.
The two forms have slightly different semantics.
.
Strings enclosed in text delimiters support
.BR ~ -tags
(described under `syntax of text lines' below) to apply text
formatting, while tildes are literal characters in double-quoted
strings.
.
.IP "" 2
In ONScripter, and previous versions of Ponscripter, double-quoted
strings had semantics similar to unmarked text \- in particular,
whitespace was ignored.
.
.IR "This is not the case in Ponscripter" ,
and the \(dq^...\(dq quoting format no longer has any special purpose,
though it is still supported for compatibility reasons (it is
equivalent to a double-quoted string).
.
.TP 2
.BR Numeric\ literals \ (\fInum_lit\fR)
are straightforward.
.
Unlike NScripter, which accepts only integer literals, Ponscripter
also understands the C-style
.BI 0x NN
notation for hexadecimal numbers.
.
.TP 2
.BR Label\ literals \ (\fIlabel\fR)
have the general format
.BI * bareword\fR.
.
They are used when a string represents the target for a jump command
.RB ( goto ", " csel ,
etc) and for the construction of subroutines with commands such as
.BR defsub ", " textgosub ,
etc.
.
.IP "" 2
They also have a special meaning at the start of a line: rather than
being interpreted as command names, label literals declare a label,
i.e. the source code location referenced by jump and
subroutine-construction commands.
.
.IP "" 2
(In NScripter, label literals are a distinct type.
.
In ONScripter they are, other than in command position, interchangable
with strings lacking the initial asterisk, and may be considered a
special bareword syntax that suppresses alias substitution.
.
This (unintentionally) permits things like computed
.BR goto s.)
.
.TP 2
.BR Variables " (\fIint_var\fR, \fIstring_var\fR)"
take the form of a sigil followed by either a number, a bareword
(which must have been defined with
.BR numalias ),
or an integer variable (with sigil) for indirect access.
.
The sigils are
.BR %
for integer variables,
.BR ?
for integer arrays, and
.BR $
for string variables.
.
.IP "" 2
Hence 
.BR %200 ", " $foo ", " $%foo ", " ?bar[10][5] .
.IP "" 2
This last example illustrates the subscript syntax for a
multidimensional array.  (See documentation of the
.BR dim
command for details of arrays.)
.
.SS Expression syntax
.
.TP 2
.BR Integer\ expressions " (\fIint_expr\fR)"
.\" ScriptHandler::readInt/parseIntExpression/readNextOp/parseInt
are similar to those in other languages.
.
There are two operator precedence levels:
.BR + " and " \-
are low precedence, while
.BR * ", " / ", and " mod
are high precedence.
.
Terms may be parenthesised to override normal precedence rules, and a
unary minus may be used to negate a term.
.
.TP 2
.BR String\ expressions " (\fIstring_expr\fR)"
.\" ScriptHandler::readStr/parseStr
are simpler.
.
Their grammar is as follows:
.IP "" 4
.BR string_expr " ::="
.IR string_term " + " string_expr
.br
.BR string_term " ::="
.IR file_cond " | " string_elt
.br
.BR file_cond "   ::="
.RI "( " string_term " ) " string_term " " string_term
.br
.BR string_elt "  ::="
.IR string_lit " | " string_var " | " label " | " bareword
.
.IP "" 2
The only part of the above that should not be obvious, given the
descriptions under `Lexical categories' above, is the
.I file_cond
term.
.
This is only useful when the
.BR filelog
command is in effect.
.
The parenthesised string is interpreted as the name of an image file.
.
If the player has viewed this file, the first of the subsequent terms
is used; otherwise, the second is used.
.
.TP 2
.B Conditional expressions
.
.SS Syntax of COMMAND lines
.
The above lexemes and expressions are combined to construct command
lines, which are structured in a fairly similar way to BASIC.
.
Commands are interpreted sequentially, one to a line; multiple
commands may be placed on a single line, where required, by separating
them with colons.
.
.PP
A command consists either of a label literal, which creates a label at
that point in the script, or a command name (in the form of a
bareword).
.
Most commands take parameters in the form of a comma-separated list of
expressions \- parentheses are not used.
.
.SS Syntax of TEXT lines
.
Text lines contain literal text, which is displayed `as is', and a
variety of tags, which have a rich variety of syntax for historical
reasons.
.
Note that the syntax described above for command lines does not apply
to text lines.
.
In particular, comments cannot be embedded in lines; semicolons are
literal characters.
.
.\" ...TODO describe...
.
.SH BUGS
.
This whole syntax may be considered a bug: it is inconvenient,
irregular, and needlessly difficult to parse.
.
Don't blame me: I didn't design it, I'm just documenting it.
.
If you want a similar tool with sane syntax, try something like
Ren'Py.
.
.SH SEE ALSO
.
.BR ponscripter (7),
.BR ponscr (6)
