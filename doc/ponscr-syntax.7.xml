<?L <!-- ?><!DOCTYPE book PUBLIC "-*-nxml-*-" "">
<book xmlns="http://docbook.org/ns/docbook"
xmlns:xl="http://www.w3.org/1999/xlink"><reference><title/><?L --> ?>

<refentry xml:id="ponscr-syntax.7">
  <info>
    <date><?D?></date>
  </info>
  <refmeta>
    <refentrytitle>ponscr-syntax</refentrytitle>
    <manvolnum>7</manvolnum>
  </refmeta>

  <refnamediv>
    <refname>ponscr-syntax</refname>
    <refpurpose>description of Ponscripter syntax</refpurpose>
  </refnamediv>

  <refsect1>
    <title>Description</title>
    <para>
      This page documents the syntax of Ponscripter scripts.  See
      &ponscripter.7; for an overview of other documentation.
    </para>
    <para>
      Note that this cannot be considered NScripter documentation.
      NScripter itself is largely unspecified.  Ponscripter's
      implementation is ultimately based on observation and
      documentation rather than on reverse-engineering as such: it
      inevitably adopts different parsing strategies, and is more
      liberal in what it accepts.  Not all differences are described
      below.  With this disclaimer out of the way: the documentation.
    </para>

    <refsect2>
      <title>Fundamentals</title>
      <para>
        Scripts are line-based.
      </para>
      <para>
        There are two parsing modes: <firstterm>command
        mode</firstterm> and <firstterm>text mode</firstterm>.
        Parsing of each line begins in command mode, and switches to
        text mode for the rest of the line if a text command is
        encountered.
      </para>
      <para>
        The two parsing modes have little in common.  The following
        sections discuss command mode first; text mode is then treated
        separately.
      </para>
      <para>
        A third mode, <quote>unmarked text</quote>, exists for legacy
        reasons.  This mode is similar to text mode, and is entered if
        an invalid character is encountered at the start of a command:
        that is, a number, a character outside the ASCII range, or
        anything in the set <literal>[[@\/%?$(!#,]</literal>.  Such
        lines are valid if they contain <emphasis>only</emphasis>
        <code>!</code>-commands; otherwise a warning is issued, and
        the behaviour is undefined.
      </para>
      <para>
        (This mode derives from NScripter, where traditionally there
        was no intersection between printable characters and command
        characters; the <code>`</code> text marker was introduced in
        ONScripter as a means of supporting English text, and replaced
        in Ponscripter with <code>^</code> to free up <code>`</code>
        for other uses.  Since unmarked text serves no useful purpose,
        and complicates parsing, it is deprecated and will be removed
        without notice at some point in the future.)
      </para>
    </refsect2>

    <refsect2>
      <title>Context</title>
      <para>
        NScripter is a context-sensitive language.  Each parameter to
        a command may be parsed differently based on the type of that
        parameter.  The major types are <type>string</type> and
        <type>integer</type>, with labels and barewords being special
        cases of string parameters.
      </para>
      <para>
        String expressions do not merely have a different type from
        integer expressions, as in other languages: they have a
        distinct syntax.  Some string expressions can be parsed as
        integer expressions, but then leave code unparsed that will
        cause a syntax error when it is reached.  It is impossible, in
        the general case, to parse a line of code unless it is known
        in advance what context each parameter is using.
      </para>
      <para>
        For example, given the following definitions:
        <programlisting>
<function>numalias</function> foo, 100
<function>stralias</function> foo, "bar"
        </programlisting>
        the constant <constant>foo</constant> would have the value
        <literal>100</literal> in integer context, but
        <literal>"bar"</literal> in string context.
      </para>
      <para>
        See the next section for more on constants, and
        <?link expression-syntax: Expression syntax?> below for
        details of the syntax accepted in each context.
      </para>
    </refsect2>

    <refsect2 xml:id="lex-cat">
      <title>Lexical categories</title>
      <para>
        The following broad lexical categories are used in command
        mode (parenthesised names are used in syntax descriptions
        below):
      </para>
      <variablelist>
        <varlistentry>
          <term><firstterm>Comments</firstterm></term>
          <listitem>
            <simpara>
              are introduced with a semicolon, and last to the end of
              the line.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Barewords</firstterm>
            (<replaceable>bareword</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the same syntax as identifiers in most programming
              languages: the first character must be in the set
              <literal>[A-Za-z_]</literal>, and the remainder must be
              in the set <literal>[A-Za-z0-9_]</literal>.
            </simpara>
            <simpara>
              A bareword at the start of a line, or immediately
              following a colon, is assumed to be a command.
              Otherwise their interpretation is context-sensitive:
            </simpara>
            <itemizedlist>
              <listitem>
                <simpara>
                  If an alias exists of the desired type (a
                  <type>numalias</type> in number context, or a
                  <type>stralias</type> in string context) then the
                  bareword acts as a constant, and the value of the
                  alias is substituted.
                </simpara>               
              </listitem>
              <listitem>
                <simpara>
                  In string context where no stralias exists, the
                  bareword itself is treated as a string; it will be
                  transformed to lower case and substituted directly.
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  In number context where no numalias exists, a
                  warning is issued and 0 is substituted.
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  Some commands, such as <function>rmenu</function>,
                  <function>ld</function>, and
                  <function>systemcall</function>, look for barewords
                  directly for certain parameters; in these cases
                  aliases are not resolved.
                </simpara>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>String literals</firstterm>
            (<replaceable>str_lit</replaceable>)
          </term>
          <listitem>
            <simpara>
              are formed in two ways.They may be enclosed in regular
              double quotes, or in pairs of the text delimiter
              (<code>^</code> in native scripts, <code>`</code> in
              legacy scripts).
            </simpara>
            <simpara>
              The two forms have slightly different semantics.
              Strings enclosed in text delimiters support
              <code>~</code>-tags (described under
              <?link text-mode: text mode?> below) to apply text
              formatting, while tildes are literal characters in
              double-quoted strings.
            </simpara>
            <simpara>
              <emphasis role='strong'>Note:</emphasis> this differs
              from ONScripter (and some pre-release versions of
              Ponscripter), where double-quoted strings had semantics
              similar to unmarked text: in particular, whitespace was
              ignored.
            </simpara>
            <simpara>
              In these interpreters, whitespace could be made
              significant in double-quoted text by following the
              opening quote with a text delimiter.  This no longer
              has any effect, but is still supported for
              backwards-compatibility: the text delimiter is
              ignored, and the construct is equivalent to a
              double-quoted string.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Numeric literals</firstterm>
            (<replaceable>num_lit</replaceable>)
          </term>
          <listitem>
            <simpara>
              are straightforward.
            </simpara>
            <simpara>
              Unlike NScripter, which accepts only decimal integers,
              Ponscripter also understands the C-style
              <literal>0x<replaceable>NN</replaceable></literal>
              notation for hexadecimal numbers.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Label literals</firstterm>
            (<replaceable>label</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the general format
              <code>*<replaceable>bareword</replaceable></code>.  They
              are used to mark and provide targets for jump commands
              (<function>goto</function>, <function>csel</function>, etc)
              and for the construction of subroutines with commands
              such as <function>defsub</function>,
              <function>textgosub</function>, etc.
            </simpara>
            <simpara>
              (In NScripter, label literals are a distinct type that
              can only be used where a command is expecting a label.
              ONScripter also accepts them wherever a string is
              expected: <literal>*foo</literal> means roughly the same
              thing as <literal>"foo"</literal>.)
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Colour literals</firstterm>
            (<replaceable>colour</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the general format
              <code>#<replaceable>RRGGBB</replaceable></code>, where
              <replaceable>RR</replaceable>,
              <replaceable>GG</replaceable>, and
              <replaceable>BB</replaceable> are each two hex digits.
              These represent colours in the standard way.
            </simpara>
            <simpara>
              (In NScripter, colour literals are a distinct type that
              can only be used where a command is expecting a colour.
              ONScripter also accepts them wherever a string is
              expected:
              <literal>#<replaceable>RRGGBB</replaceable></literal>
              means exactly the same thing as
              <literal>"#<replaceable>RRGGBB</replaceable>"</literal>.)
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Variables</firstterm>
            (<replaceable>int_var</replaceable>,
             <replaceable>str_var</replaceable>)
          </term>
          <listitem>
            <simpara>
              take the form of a sigil followed by either a number, a
              bareword (which must have been defined with
              <function>numalias</function>), or an integer variable
              (with sigil) for indirect access.
            </simpara>
            <simpara>
              The sigils are <code>%</code> for integer variables,
              <code>?</code> for integer arrays, and <code>$</code>
              for string variables.
            </simpara>
            <simpara>
              Hence <varname>%200</varname> (an integer variable),
              <varname>$%foo</varname> (the string variable indexed by
              the current value of <varname>%foo</varname>), and
              <code><varname>?bar</varname>[9][4]</code>
              (dereferencing the multidimensional array
              <varname>?bar</varname>).
            </simpara>
            <simpara>
              Variable syntax is expressed formally in the expression
              sections below.
            </simpara>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2 xml:id="expression-syntax">
      <title>Expression syntax</title>
      
      <variablelist>
        <varlistentry>
          <term>
            <firstterm>Integer expressions</firstterm>
            (<replaceable>int_expr</replaceable>)
          </term>
          <listitem>
            <para>
              are similar to those in other languages.  The syntax is
              infix.  There are two operator precedence levels:
              <code>*</code>, <code>/</code>, and <code>mod</code> are
              processed before <code>+</code> and <code>-</code>.
              Parentheses and unary minus operate as normal.
            </para>
            <para>More formally:</para>
            <informaltable border="0" rules="none">
              <tbody>
                <tr>
                  <td><firstterm>int_expr</firstterm></td><td>::=</td>
                  <td><replaceable>int_term</replaceable> <replaceable>binary_op</replaceable> <replaceable>int_expr</replaceable></td>
                </tr>
                <tr>
                  <td><firstterm>int_term</firstterm></td><td>::=</td>
                  <td><replaceable>int_paren</replaceable> | <quote>-</quote> <replaceable>int_paren</replaceable></td>
                </tr>
                <tr>
                  <td><firstterm>int_paren</firstterm></td><td>::=</td>
                  <td><quote>(</quote> <replaceable>int_expr</replaceable> <quote>)</quote> | <replaceable>int_elt</replaceable></td>
                </tr>
                <tr>
                  <td><firstterm>int_elt</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>num_lit</replaceable> | <replaceable>int_var</replaceable> | <replaceable>bareword</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>int_var</firstterm></td><td>::=</td>
                  <td>
                    <quote>%</quote> <replaceable>int_elt</replaceable> | <quote>?</quote> <replaceable>int_elt</replaceable> <replaceable>subscript</replaceable>+
                  </td>
                </tr>
                <tr>
                  <td><firstterm>subscript</firstterm></td><td>::=</td>
                  <td>
                    <quote>[</quote> <replaceable>int_expr</replaceable> <quote>]</quote>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>binary_op</firstterm></td><td>::=</td>
                  <td>
                    <quote>*</quote> | <quote>/</quote> | <quote>mod</quote> | <quote>+</quote> | <quote>-</quote>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>num_lit</firstterm></td><td>::=</td>
                  <td>
                    <literal>[0-9]+</literal> | <literal>0x[0-9A-Fa-f]+</literal>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>bareword</firstterm></td><td>::=</td>
                  <td>
                    <literal>[A-Za-z_][A-Za-z_0-9]*</literal>
                  </td>
                </tr>
              </tbody>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <firstterm>String expressions</firstterm>
            (<replaceable>str_expr</replaceable>)
          </term>
          <listitem>
            <para>
              are simpler.  Their grammar is as follows:
            </para>
            <informaltable border="0" rules="none">
              <tbody>
                <tr>
                  <td><firstterm>str_expr</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>str_elt</replaceable> | <replaceable>str_elt</replaceable> <quote>+</quote> <replaceable>str_expr</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>str_elt</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>file_cond</replaceable> | <replaceable>str_lit</replaceable> | <replaceable>str_var</replaceable> | <replaceable>label</replaceable> | <replaceable>colour</replaceable> | <replaceable>bareword</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>file_cond</firstterm></td><td>::=</td>
                  <td>
                    <quote>(</quote> <replaceable>str_term</replaceable> <quote>)</quote> <replaceable>str_term</replaceable> <replaceable>str_term</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>str_var</firstterm></td><td>::=</td>
                  <td>
                    <quote>$</quote> <replaceable>int_elt</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>str_lit</firstterm></td><td>::=</td>
                  <td>
                    <literal>"[^"]*?"</literal> | <literal>^[^^]*?^</literal>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>label</firstterm></td><td>::=</td>
                  <td>
                    <quote>*</quote> <literal>[A-Za-z_0-9]+</literal>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>colour</firstterm></td><td>::=</td>
                  <td>
                    <quote>#</quote> <literal>[0-9A-Fa-f]{6}</literal>
                  </td>
                </tr>
              </tbody>
            </informaltable>
            <para>
              The only part of the above that should not be obvious, given
              the descriptions under <?link lex-cat: Lexical categories?>
              above, is the <replaceable>file_cond</replaceable> term.  This
              is only useful when the <function>filelog</function> command
              is in effect.  The parenthesised string is interpreted as the
              name of an image file.  If the player has viewed this file,
              the first of the subsequent terms is used; otherwise, the
              second is used.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <firstterm>Conditional expressions</firstterm>
            (<replaceable>conditional</replaceable>)
          </term>
          <listitem>
            <para>
              are effectively a special syntax associated with the
              <function>if</function> / <function>notif</function>
              commands.
            </para>
            <para>
              They are somewhat lacking compared to conditionals in
              most languages: in particular, multiple terms may be
              combined only with an <quote>and</quote> operator, with
              no <quote>or</quote> available.
            </para>
            <para>
              Either strings or integers may be compared.  The
              ordering of strings is deliberately left undefined; it
              may change without warning in the future.  However, for
              any given Ponscripter version, the ordering will be the
              same across all platforms and will not be affected by
              users' locale settings.
            </para>
            <para>
              The operators are C-style: <code>==</code> and
              <code>!=</code> for equality and inequality;
              <code>&lt;</code>, <code>&lt;=</code>,
              <code>&gt;</code>, and <code>&gt;=</code> for ordering;
              and <code>&amp;</code> to combine terms with a logical
              <quote>and</quote>.
            </para>
            <para>
              (Several operators accept variant forms:
              <code>&amp;&amp;</code> for <code>&amp;</code>,
              <code>=</code> for <code>==</code>, and
              <code>&lt;&gt;</code> for <code>!=</code>.  These
              variants have no semantic difference from the canonical
              forms.)
            </para>
            <para>
              Functions cannot be called from conditional expressions
              (you must assign the result of a function to a variable,
              and compare that manually), with one exception: there is
              hardcoded support for a function
              <function>fchk</function>, which takes a string,
              interprets it as the filename of a picture, and returns
              true iff that picture has been displayed.  (This is
              analogous to the <replaceable>file_cond</replaceable>
              term in string expressions.)
            </para>
            <para>
              The grammar is:
            </para>
            <informaltable border="0" rules="none">
              <tbody>
                <tr>
                  <td><firstterm>conditional</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>cond_term</replaceable> | <replaceable>cond_term</replaceable> <quote>&amp;</quote> <replaceable>conditional</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>cond_term</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>comp_term</replaceable> | <quote>fchk</quote> <replaceable>str_expr</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>comparison</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>expression</replaceable> <replaceable>comp_op</replaceable> <replaceable>expression</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>expression</firstterm></td><td>::=</td>
                  <td>
                    <replaceable>int_expr</replaceable> | <replaceable>str_expr</replaceable>
                  </td>
                </tr>
                <tr>
                  <td><firstterm>comp_op</firstterm></td><td>::=</td>
                  <td>
                    <quote>==</quote> | | <quote>!=</quote> | <quote>&gt;</quote> | <quote>&gt;=</quote> | <quote>&lt;</quote> | <quote>&lt;=</quote>
                  </td>
                </tr>
              </tbody>
            </informaltable>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Command syntax</title>
      <para>
        The above lexemes and expressions are combined in a fairly
        similar way to BASIC.  Commands are interpreted sequentially,
        one to a line; multiple commands may be placed on a single
        line, where required, by separating them with colons.
      </para>
      <para>
        There are several forms of command:
        <itemizedlist>
          <listitem>
            <simpara>
              <firstterm>Procedure call</firstterm>s consist of a
              bareword, normally followed by a parameter list: this is
              a comma-separated list of expressions (parentheses are
              not used).
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <firstterm>Label</firstterm>s consist of a label
              literal, which serves as a name for that point in the
              script.
            </simpara>
            <simpara>
              There is also a form of anonymous label, represented by
              a single <code>~</code> character, which is used by the
              <command>jumpf</command> and <command>jumpb</command>
              commands.
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <firstterm>Text</firstterm> commands consist of a text
              delimiter, which switches the interpreter into text mode
              for the remainder of the line; see next section.
            </simpara>
          </listitem>
        </itemizedlist>
      </para>
    </refsect2>

    <refsect2 xml:id="text-mode">
      <title>Text mode</title>
      <para>
        As described above, text commands begin with a text marker
        (<code>^</code> in native scripts, <code>`</code> in legacy
        scripts).  The remainder of the line is then parsed in text
        mode.
      </para>
      <para>
        Most characters in text mode represent themselves and are
        printed verbatim; this includes the newline at the end of each
        line, unless it is explicitly suppressed with <code>/</code>.
        It also includes characters with special meanings in command
        mode, such as colons and semicolons.
      </para>
      <para>
        However, there are also a fair number of control characters
        with special meanings.  Since text syntax was not so much
        designed as gradually accumulated, there is very little
        consistency in how these control characters are chosen, when
        exactly in the parsing process they are interpreted, and how
        they are printed literally.  Read on for details.
      </para>
    </refsect2>

    <refsect2>
      <title>Text control</title>
      <para>
        Single characters with special meanings.  These characters may
        all be printed literally by prefixing them with a single hash
        character, i.e. <literal>#@</literal>, <literal>#_</literal>,
        etc.
      </para>
      <variablelist>
        <varlistentry>
          <term><literal>@</literal></term>
          <listitem>
            <simpara>
              Waits for click, then continues printing text as though
              nothing had happened.  (Unlike in many ONScripter
              builds, the behaviour of <literal>@</literal> is not altered
              by the definition of a <function>textgosub</function>
              routine.)
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>\</literal></term>
          <listitem>
            <simpara>
              Waits for a click, then clears the text window and
              begins a new page.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>_</literal></term>
          <listitem>
            <simpara>
              If a character has the <function>clickstr</function>
              nature, prefixing it with an underscore suppresses that
              behaviour; otherwise it does nothing whatsoever.
              <function>clickstr</function> is evil, so you should
              never need to use this.  Place your pauses explicitly.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>/</literal></term>
          <listitem>
            <simpara>
              At the end of a line, ends a text command without
              beginning a new line of display text.  This control only
              has any effect <emphasis>immediately</emphasis> before a
              newline character.  Anywhere else in a line, even if
              only whitespace follows, it prints a literal slash.
            </simpara>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Speed control</title>
      <para>
        Multi-character control codes controlling text speed.
      </para>
      <para>
        Whitespace after these codes is ignored; you can cause it to
        be treated literally by adding a trailing separator character,
        i.e. <function>!sd</function><literal>|</literal> etc.
      </para>
      <para>
        If one of these sequences would appear in literal text, it can
        be escaped by prefixing it with a single hash character, i.e.
        <literal>#!sd</literal> etc.
      </para>
      <para>
        Due to existing conventions for script layout, these codes are
        also valid as standalone commands without a preceding text
        marker; in this case they must be the only thing on their line
        apart from whitespace.
      </para>
      <variablelist>
        <varlistentry>
          <term><function>!s</function><replaceable>NUM</replaceable></term>
          <listitem>
            <para>
              Sets text speed; this is equivalent to the commmand
              <programlisting>
<function>textspeed</function> <replaceable>NUM</replaceable>
              </programlisting>
              but has a more convenient syntax in cases where the
              speed must change within a single line.
            </para>
            <para>
              Lower speeds are faster; <literal>0</literal> means
              there should be no deliberate delay between characters,
              though (as they are still printed one at a time) it may
              not quite lead to instantaneous display.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><function>!sd</function></term>
          <listitem>
            <para>
              Resets text speed to the current player-selected
              default.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><function>!w</function><replaceable>NUM</replaceable></term>
          <listitem>
            <para>
              Inserts a pause of <replaceable>NUM</replaceable>
              milliseconds.  It cannot be truncated by clicking, but
              can be skipped with any of the normal skip commands.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><function>!d</function><replaceable>NUM</replaceable></term>
          <listitem>
            <para>
              As <function>!w</function>, but the pause can also be
              truncated by clicking.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2>
      <title>Colour tags</title>
      <para>
        <literal>#</literal><replaceable>RRGGBB</replaceable>, where
        <replaceable>RR</replaceable>, <replaceable>GG</replaceable>,
        and <replaceable>BB</replaceable> are each two hex digits,
        modifies the current text foreground colour in the obvious
        way.  A literal hash character can be inserted with
        <literal>##</literal>.
      </para>
    </refsect2>

    <refsect2>
      <title>Formatting tags</title>
      <para>
        All formatting other than text colour is performed with
        formatting tag blocks.  These are delimited with tildes; a
        literal tilde can be inserted with <literal>~~</literal>
        (<emphasis>not</emphasis> <literal>#~</literal>... that would
        be consistent.)
      </para>
      <para>
        Any number of tags can be combined within a single block,
        optionally separated with whitespace.
      </para>
      
      <variablelist>
        <varlistentry xml:id="f-sel-t">
          <term>Font selection tags</term>
          <listitem>
            <para>
              The tags in this section, with the exception of
              <function>c</function>, assume that Ponscripter's eight
              font slots are assigned according to the following
              convention:
            </para>
            <literallayout>  0 - text regular
  1 - text italic
  2 - text bold
  3 - text bold italic
  4 - display regular
  5 - display italic
  6 - display bold
  7 - display bold italic
<?IFman <!-- nasty hack to make whitespace work -->
?></literallayout>
            <para>
              If fonts are assigned in any other way, tags such as
              <function>b</function> and <function>i</function> will
              not behave as documented; you should use
              <function>c</function> in this case.  Font slots are
              assigned using the <function>h_mapfont</function>
              command, which is documented in &ponscr-ext.7;.
            </para>

            <variablelist>
              <varlistentry>
                <term><function>c</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Selects the font in slot <replaceable>N</replaceable>
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>d</function></term>
                <listitem>
                  <simpara>
                    Selects the default style (equivalent to
                    <function>c0</function>)
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>r</function></term>
                <listitem>
                  <simpara>
                    Disables italics (default)
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>i</function></term>
                <listitem>
                  <simpara>
                    Toggles italics
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>t</function></term>
                <listitem>
                  <simpara>
                    Disables bold weight (default)
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>i</function></term>
                <listitem>
                  <simpara>
                    Toggles bold weight
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>f</function></term>
                <listitem>
                  <simpara>
                    Selects text face (default)
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>s</function></term>
                <listitem>
                  <simpara>
                    Toggles display face
                  </simpara>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Text size</term>
          <listitem>
            <para>
              In this section, the <firstterm>base size</firstterm>
              refers to the font size defined for the active window;
              the <firstterm>current size</firstterm> refers to that
              selected with previous size control tags.
            </para>
            <variablelist>
              <varlistentry>
                <term><function>=</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Sets font size to exactly
                    <replaceable>N</replaceable> pixels.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>%</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Sets font size to <replaceable>N</replaceable>% of
                    the base size.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>+</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Increases current font size by
                    <replaceable>N</replaceable> pixels.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>-</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Decreases current font size by
                    <replaceable>N</replaceable> pixels.
                  </simpara>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Text position</term>
          <listitem>
            <variablelist>
              <varlistentry>
                <term><function>x</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Sets the horizontal text position to a position
                    <replaceable>N</replaceable> pixels right of the
                    left margin.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>y</function><replaceable>N</replaceable></term>
                <listitem>
                  <simpara>
                    Sets the vertical text position to a position
                    <replaceable>N</replaceable> pixels below the
                    top margin.
                    <!-- TODO: is this the top or the baseline? -->
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>x+</function><replaceable
                >N</replaceable></term>
                <term><function>y+</function><replaceable
                >N</replaceable></term>
                <listitem>
                  <simpara>
                    Adjusts the current horizontal or vertical text
                    position by <replaceable>N</replaceable> pixels
                    right or down.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>x-</function><replaceable
                >N</replaceable></term>
                <term><function>y-</function><replaceable
                >N</replaceable></term>
                <listitem>
                  <simpara>
                    Adjusts the current horizontal or vertical text
                    position by <replaceable>N</replaceable> pixels
                    left or up.
                  </simpara>
                </listitem>
              </varlistentry>
             </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Indentation</term>
          <listitem>
            <variablelist>
              <varlistentry>
                <term><function>n</function></term>
                <listitem>
                  <simpara>
                    Sets the indent to the current horizontal
                    position.  New text lines will start from this
                    offset until the end of the current page.
                  </simpara>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><function>u</function></term>
                <listitem>
                  <simpara>
                    Resets the indent to the left margin.  This will
                    only affect <emphasis>subsequent</emphasis> line
                    breaks; to end an indented section within a page,
                    position this at the end of the last line of the
                    indented section.
                  </simpara>
                </listitem>
              </varlistentry>
            </variablelist>
            <para>
              In addition to these tags, the indent is set
              automatically when the first character of a page is an
              <firstterm>indent character.</firstterm>
            </para>
            <para>
              The set of indent characters can be configured with the
              <function>h_indentstr</function> command (described in
              &ponscr-ext.7;).  By default it includes opening quotes
              and em dashes.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Formatting examples</term>
          <listitem>
            <para>
              As an example of the usage of these tags, Narcissu 2's
              omake mode displays page headings at the top of each
              screen with code like
              <programlisting>
^<function>!s0</function>~i %120 x-20 y-40~Heading~i =0~<function>!sd</function>
<function>br2</function> 120
              </programlisting>
              Here the <function>!s0</function> and
              <function>!sd</function> are the usual NScripter
              commands.  The first tag block selects italic text, 120%
              of the regular font size, and shifts the output position
              up and to the left.  The second tag block cancels the
              italic effect and resets the font size to normal.
            </para>
            <para>
              An example of indentation:
              <programlisting>
^**%.Item 1
^Not indented
^**%.~n~Item 2
^Indented~u~
^Not indented
              </programlisting>
            </para>
          </listitem>
        </varlistentry>

      </variablelist>
    </refsect2>

    <refsect2 xml:id="ligs">
      <title>Ligatures and shortcuts</title>
      <para>
        To assist in typing Unicode scripts with ASCII keyboards,
        Ponscripter has the ability to replace sequences of characters
        with Unicode symbols.  This facility is also used to implement
        the hash-escaping of single-character control codes, and can
        be used to add ligatures automatically.  It is only enabled in
        native scripts; none of this is possible in legacy mode.
      </para>
      <para>
        A shortcut is a mapping of a sequence of characters to a
        Unicode codepoint.

        <!-- TODO explain concept and search sequence -->

      </para>
      <para>
        A shortcut sequence can be inserted literally by separating
        the characters with either a Unicode ZWNJ or a
        <literal>|</literal> character, e.g. <literal>`|`</literal> to
        insert two separate open single quotes.  A literal
        <literal>|</literal> can be inserted with
        <literal>||</literal>.
      </para>
      <para>
        By default, the following character sequences are defined, in
        addition to the hash escapes described above:
      </para>
      <variablelist>
        <varlistentry>
          <term><literal>``</literal></term>
          <listitem><simpara>open double quotes</simpara></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>''</literal></term>
          <listitem><simpara>close double quotes</simpara></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>`</literal></term>
          <listitem><simpara>open single quote</simpara></listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>'</literal></term>
          <listitem>
            <simpara>apostrophe / close single quote</simpara>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Additional sequences can be defined by use of the
        <function>h_ligate</function> command: see &ponscr-ext.7;.
      </para>
    </refsect2>

    <refsect2>
      <title>Variable interpolation</title>
      <para>
        Unlike in vanilla NScripter, merely including the name of a
        variable in text does not cause it to be interpolated; this is
        because frankly it seems to be more common to want something
        like <literal>$500</literal> to be literal text representing a
        sum of money.
      </para>
      <para>
        Instead, variables will be interpolated if enclosed in braces:
        <literal>{$foo}</literal>, <literal>{?100[%index]}</literal>,
        and so forth.  This is not to be confused with NScripter's
        rather less useful brace syntax (variable assignments), which
        is not supported.
      </para>
      <para>
        The variable's sigil must immediately follow the opening
        brace, and only variables can be interpolated, not arbitrary
        expressions.  To include a literal sequence of a left brace
        followed by a sigil character, use a separator character:
        <literal>{|%</literal>.
      </para>
      <para>
        Certain control codes are recognised after variable
        interpolation, since they are parsed at a later stage of
        processing: these are text controls, speed controls, colour
        tags, and ligatures/shortcuts.  In particular, and in contrast
        to NScripter, things like <literal>^!w{%var}</literal> will be
        interpreted as a command to wait for however long is specified
        in the given variable.  This should be considered an undefined
        behaviour, and will probably change in future; rather than
        rely on it, you should use the <function>wait</function>
        command (and so forth) for variable timings, and in the
        unlikely event that you actually intend to print the literal
        string <literal>!w</literal> followed by the value of
        <replaceable>%var</replaceable>, you should write
        <literal>#!w{%var}</literal> to avoid ambiguity.
      </para>
      <para>
        Other special sequences are not recognised after
        interpolation.  Variable interpolations are not expanded
        recursively.  Likewise, formatting codes are not processed
        during interpolation; however, if the string literal in which
        they first appeared was delimited with <literal>^</literal>
        rather than <literal>"</literal>, they will have been
        processed when the string was read, and will therefore work as
        intended.
      </para>
      <para>
        That is to say,
        <programlisting>
<function>mov</function> $var, "~b~"
^foo{$var}bar\
        </programlisting>
        prints <screen>foo~b~bar</screen>, while
        <programlisting>
<function>mov</function> $var, ^~b~^
^foo{$var}bar\
        </programlisting>
        prints <screen>foo<emphasis role="strong">bar</emphasis></screen>.
      </para>
    </refsect2>
  </refsect1>

  <refsect1>
    <title>Bugs</title>
    <simpara>
      This whole syntax may be considered a bug: it is inconvenient,
      irregular, and needlessly difficult to parse.  Don't blame me: I
      didn't design it, I'm just documenting it.  If you want a
      similar tool with sane syntax, try something like Ren'Py.
    </simpara>
  </refsect1>

  <refsect1>
    <title>See also</title>
    <simpara>&ponscripter.7;</simpara>
  </refsect1>
  
</refentry>

<?L <!-- ?></reference></book><?L --> ?>
