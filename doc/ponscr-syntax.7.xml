<?L <!-- ?><!DOCTYPE book PUBLIC "-*-nxml-*-" "">
<book xmlns="http://docbook.org/ns/docbook"
xmlns:xl="http://www.w3.org/1999/xlink"><reference><title/><?L --> ?>

<refentry xml:id="ponscr-syntax.7">
  <info>
    <date><?D?></date>
  </info>
  <refmeta>
    <refentrytitle>ponscr-syntax</refentrytitle>
    <manvolnum>7</manvolnum>
  </refmeta>

  <refnamediv>
    <refname>ponscr-syntax</refname>
    <refpurpose>description of Ponscripter syntax</refpurpose>
  </refnamediv>

  <refsect1>
    <title>Description</title>
    <para>
      This page documents the syntax of Ponscripter scripts.  See
      &ponscripter.7; for an overview of other documentation.
    </para>
    <para>
      Note that this cannot be considered NScripter documentation.
      NScripter itself is largely unspecified.  Ponscripter's
      implementation is ultimately based on observation and
      documentation rather than on reverse-engineering as such: it
      inevitably adopts different parsing strategies, and is more
      liberal in what it accepts.  Not all differences are described
      below.  With this disclaimer out of the way: the documentation.
    </para>

    <refsect2>
      <title>Fundamentals</title>
      <para>
        Scripts are line-based.
      </para>
      <para>
        There are two parsing modes: <firstterm>command
        mode</firstterm> and <firstterm>text mode</firstterm>.
        Parsing of each line begins in command mode, and switches to
        text mode for the rest of the line if a text command is
        encountered.
      </para>
      <para>
        The two parsing modes have little in common.  The following
        sections discuss command mode first; text mode is then treated
        separately.
      </para>
      <para>
        A third mode, <quote>unmarked text</quote>, exists for legacy
        reasons.  This mode is similar to text mode, and is entered if
        an invalid character is encountered at the start of a command:
        that is, a number, a character outside the ASCII range, or
        anything in the set <literal>[[@\/%?$(!#,]</literal>.  Such
        lines are valid if they contain <emphasis>only</emphasis>
        <code>!</code>-commands; otherwise a warning is issued, and
        the behaviour is undefined.
      </para>
      <para>
        (This mode derives from NScripter, where traditionally there
        was no intersection between printable characters and command
        characters; the <code>`</code> text marker was introduced in
        ONScripter as a means of supporting English text, and replaced
        in Ponscripter with <code>^</code> to free up <code>`</code>
        for other uses.  Since unmarked text serves no useful purpose,
        and complicates parsing, it is deprecated and will be removed
        without notice at some point in the future.)
      </para>
    </refsect2>

    <refsect2>
      <title>Context</title>
      <para>
        NScripter is a context-sensitive language.  Each parameter to
        a command may be parsed differently based on the type of that
        parameter.  The major types are <type>string</type> and
        <type>integer</type>, with labels and barewords being special
        cases of string parameters.
      </para>
      <para>
        String expressions do not merely have a different type from
        integer expressions, as in other languages: they have a
        distinct syntax.  Some string expressions can be parsed as
        integer expressions, but then leave code unparsed that will
        cause a syntax error when it is reached.  It is impossible, in
        the general case, to parse a line of code unless it is known
        in advance what context each parameter is using.
      </para>
      <para>
        For example, given the following definitions:
        <programlisting>
numalias foo, 100
stralias foo, "bar"
        </programlisting>
        the constant <constant>foo</constant> would have the value
        <literal>100</literal> in integer context, but
        <literal>"bar"</literal> in string context.
      </para>
      <para>
        See the next section for more on constants, and
        <?link expression-syntax: Expression syntax?> below for
        details of the syntax accepted in each context.
      </para>
    </refsect2>

    <refsect2>
      <title>Lexical categories</title>
      <para>
        The following broad lexical categories are used in command
        mode (parenthesised names are used in syntax descriptions
        below):
      </para>
      <variablelist>
        <varlistentry>
          <term><firstterm>Comments</firstterm></term>
          <listitem>
            <simpara>
              are introduced with a semicolon, and last to the end of
              the line.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Barewords</firstterm>
            (<replaceable linkend="expr-bareword">bareword</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the same syntax as identifiers in most programming
              languages: the first character must be in the set
              <literal>[A-Za-z_]</literal>, and the remainder must be
              in the set <literal>[A-Za-z0-9_]</literal>.
            </simpara>
            <simpara>
              A bareword at the start of a line, or immediately
              following a colon, is assumed to be a command.
              Otherwise their interpretation is context-sensitive:
            </simpara>
            <itemizedlist>
              <listitem>
                <simpara>
                  If an alias exists of the desired type (a
                  <type>numalias</type> in number context, or a
                  <type>stralias</type> in string context) then the
                  bareword acts as a constant, and the value of the
                  alias is substituted.
                </simpara>               
              </listitem>
              <listitem>
                <simpara>
                  In string context where no stralias exists, the
                  bareword itself is treated as a string; it will be
                  transformed to lower case and substituted directly.
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  In number context where no numalias exists, a
                  warning is issued and 0 is substituted.
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  Some commands, such as <command>rmenu</command>,
                  <command>ld</command>, and
                  <command>systemcall</command>, look for barewords
                  directly for certain parameters; in these cases
                  aliases are not resolved.
                </simpara>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>String literals</firstterm>
            (<replaceable>string_lit</replaceable>)
          </term>
          <listitem>
            <simpara>
              are formed in two ways.They may be enclosed in regular
              double quotes, or in pairs of the text delimiter
              (<code>^</code> in native scripts, <code>`</code> in
              legacy scripts).
            </simpara>
            <simpara>
              The two forms have slightly different semantics.
              Strings enclosed in text delimiters support
              <code>~</code>-tags (described under
              <?link text-mode: text mode?> below) to apply text
              formatting, while tildes are literal characters in
              double-quoted strings.
            </simpara>
            <simpara>
              <emphasis role='strong'>Note:</emphasis> this differs
              from ONScripter (and some pre-release versions of
              Ponscripter), where double-quoted strings had semantics
              similar to unmarked text: in particular, whitespace was
              ignored.
            </simpara>
            <simpara>
              In these interpreters, whitespace could be made
              significant in double-quoted text by following the
              opening quote with a text delimiter.  This no longer
              has any effect, but is still supported for
              backwards-compatibility: the text delimiter is
              ignored, and the construct is equivalent to a
              double-quoted string.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Numeric literals</firstterm>
            (<replaceable>num_lit</replaceable>)
          </term>
          <listitem>
            <simpara>
              are straightforward.
            </simpara>
            <simpara>
              Unlike NScripter, which accepts only decimal integers,
              Ponscripter also understands the C-style
              <literal>0x<replaceable>NN</replaceable></literal>
              notation for hexadecimal numbers.
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Label literals</firstterm>
            (<replaceable>label</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the general format
              <code>*<replaceable>bareword</replaceable></code>.  They
              are used to provide targets for jump commands
              (<command>goto</command>, <command>csel</command>, etc)
              and for the construction of subroutines with commands
              such as <command>defsub</command>,
              <command>textgosub</command>, etc.
            </simpara>
            <simpara>
              A label literal may also stand alone as a command
              itself.  In this case they function as label
              declarations, i.e. they mark the source code location
              referenced by label parameters to the above commands.
            </simpara>
            <simpara>
              (In NScripter, label literals are a distinct type that
              can only be used where a command is expecting a label.
              ONScripter also accepts them wherever a string is
              expected: <literal>*foo</literal> means roughly the same
              thing as <literal>"foo"</literal>.)
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Colour literals</firstterm>
            (<replaceable>colour</replaceable>)
          </term>
          <listitem>
            <simpara>
              have the general format
              <code>#<replaceable>RRGGBB</replaceable></code>, where
              <replaceable>RR</replaceable>,
              <replaceable>GG</replaceable>, and
              <replaceable>BB</replaceable> are each two hex digits.
              These represent colours in the standard way.
            </simpara>
            <simpara>
              (In NScripter, colour literals are a distinct type that
              can only be used where a command is expecting a colour.
              ONScripter also accepts them wherever a string is
              expected:
              <literal>#<replaceable>RRGGBB</replaceable></literal>
              means exactly the same thing as
              <literal>"#<replaceable>RRGGBB</replaceable>"</literal>.)
            </simpara>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <firstterm>Variables</firstterm>
            (<replaceable>int_var</replaceable>,
             <replaceable>string_var</replaceable>)
          </term>
          <listitem>
            <simpara>
              take the form of a sigil followed by either a number, a
              bareword (which must have been defined with
              <command>numalias</command>), or an integer variable
              (with sigil) for indirect access.
            </simpara>
            <simpara>
              The sigils are <code>%</code> for integer variables,
              <code>?</code> for integer arrays, and <code>$</code>
              for string variables.
            </simpara>
            <simpara>
              Hence <varname>%200</varname> (an integer variable),
              <varname>$%foo</varname> (the string variable indexed by
              the current value of <varname>%foo</varname>), and
              <code><varname>?bar</varname>[9][4]</code>
              (dereferencing the multidimensional array
              <varname>?bar</varname>).
            </simpara>
            <simpara>
              Variable syntax is expressed formally in the expression
              sections below.
            </simpara>
          </listitem>
        </varlistentry>
      </variablelist>
    </refsect2>

    <refsect2 xml:id="expression-syntax">
      <title>Expression syntax</title>
      <para></para>
    </refsect2>
    
  </refsect1>    
      
<!--
.SS Expression syntax

.TP 2
.BR Integer\ expressions " (\fIint_expr\fR)"
.\" ScriptHandler::readInt/parseIntExpression/readNextOp/parseInt
are similar to those in other languages.

There are two operator precedence levels:
.BR + " and " \-
are low precedence, while
.BR * ", " / ", and " mod
are high precedence.

Parentheses and unary minus operate as normal.

.IP "" 2
More formally:

.IP "" 4
.BR int_expr "  ::="
.IB int_term " \fR| " int_term \ *\fR|\fB/\fR|\fBmod \ int_expr
.br
.BR int_term "  ::="
.IB int_unary " \fR| " int_unary \ +\fR|\fB\- \ int_term
.br
.BR int_unary " ::="
.IR int_paren " | \fB\- " int_paren
.br
.BR int_paren " ::="
.BI "( " int_expr " ) \fR| " int_elt
.br
.BR int_elt "   ::="
.IR num_lit " | " int_var " | " bareword
.br
.BR int_var "   ::="
.BI % int_elt " \fR| " int_array
.br
.BR int_array " ::="
.BI ? "int_elt subscript" \fR+
.br
.BR subscript " ::="
.BI "[ " int_expr " ]"
.br
.BR num_lit "   ::="
.IR [0\-9]+ " | \fB0x" [0-9a-f]+
.br
.BR bareword "  ::="
.IR [a-z_][a-z_0-9]+

.TP 2
.BR String\ expressions " (\fIstring_expr\fR)"
.\" ScriptHandler::readStr/parseStr
are simpler.

Their grammar is as follows:
.IP "" 4
.BR string_expr " ::="
.IB string_term " | " string_term " + " string_expr
.br
.BR string_term " ::="
.IR file_cond " | " string_elt
.br
.BR file_cond "   ::="
.BI "( " string_term " ) " string_term " " string_term
.br
.BR string_elt "  ::="
.IR string_lit " | " string_var " | " label " | " colour " | " bareword
.br
.BR string_var "  ::="
.BI $ int_elt
.br
.BR label "       ::="
.BI * [a-z_0-9]+
.br
.BR string_lit "  ::="
.BI \(dq [^\(dq]*? \(dq "\fR | " ^ [^^]*? ^

.IP "" 2
The only part of the above that should not be obvious, given the
descriptions under `Lexical categories' above, is the
.I file_cond
term.

This is only useful when the
.BR filelog
command is in effect.

The parenthesised string is interpreted as the name of an image file.

If the player has viewed this file, the first of the subsequent terms
is used; otherwise, the second is used.

.TP 2
.B Conditional expressions

are effectively a special syntax associated with the
.BR if / notif
commands.

They are somewhat lacking compared to conditionals in most languages:
in particular, multiple terms may be combined only with an `and'
operator, with no `or' available.

.IP "" 2
Either strings or integers may be compared.

The ordering of strings is deliberately left undefined; it may change
without warning in the future.

However, for any given Ponscripter version, the ordering will be the
same across all platforms and regardless of users' locale settings.

.IP "" 2
Several operators accept variant forms:
.BR && \ for \ & ,
.BR = \ for \ == ,
and
.BR <> \ for \ != .
In each case, there is no semantic difference between the two.

.IP "" 2
One other type of term is permitted: a function-like
.BR fchk ,
which takes a string, interprets it as the filename of a picture,
and returns true iff that picture has been displayed.

.IP "" 2
Formally:

.IP "" 4
.BR conditional " ::="
.IR cond_term " | " cond_term " \fB& " conditional
.br
.BR cond_term "   ::="
.IR comp_term " | \fBfchk " string_expr
.br
.BR comp_term "   ::="
.IB expression " ==\fR|\fB!=\fR|\fB>\fR|\fB<\fR|\fB>=\fR|\fB<= " expression
.br
.BR expression "  ::="
.IR int_expr " | " string_expr

.SS Command syntax

The above lexemes and expressions are combined in a fairly similar way
to BASIC.

Commands are interpreted sequentially, one to a line; multiple
commands may be placed on a single line, where required, by separating
them with colons.

.PP
There are several forms of command:

.IP \(bu
.BR Procedure\ call s
consist of a bareword, normally followed by a parameter list: this is
a comma-separated list of expressions (parentheses are not used).

.IP \(bu
.BR Label s
consist of a label literal, which serves as a name for that point in
the script.

There is also a form of anonymous label, represented by a single
.B ~
character, which is used by the
.B jumpf
and
.B jumpb
commands.

.IP \(bu
.BR Text
commands consist of a text delimiter, which switches the interpreter
into text mode for the remainder of the line; see next section.

.SS Text mode

As described above, text commands begin with a text marker
.RB ( ^
in native scripts,
.B \`
in legacy scripts).

The remainder of the line is then parsed in text mode.

.PP
Most characters in text mode represent themselves and are printed
verbatim; this includes the newline at the end of each line, unless
it is explicitly suppressed with
.BR / .

It also includes characters with special meanings in command mode,
such as colons and semicolons.

However, there are also a fair number of control characters with
special meanings.

Since text syntax was not so much designed as gradually accumulated,
there is very little consistency in how these control characters are
chosen, when exactly in the parsing process they are interpreted, and
how they are printed literally.

Read on for details.

.SS Text control

Single characters with special meanings.

These characters may all be printed literally by prefixing them with
a single hash character, i.e.
.BR #@ ", " #_ ,
etc.

.TP 2
.BR @
Waits for click, then continues printing text as though nothing had
happened.

.IP "" 2
(Unlike in many ONScripter builds, the behaviour of
.BR @
is not altered by the definition of a
.BR textgosub
routine.)

.TP 2
.BR \e
Waits for a click, then clears text window and begin a new page.

.TP 2
.BR _
If a character has the
.BR clickstr
nature, prefixing it with an underscore suppresses that behaviour;
otherwise it does nothing whatsoever.

.IP "" 2
.BR clickstr
is evil, so you should never need to use this.

.TP 2
.BR /
At the end of a line, ends a text command without beginning a new line
of display text.

This control only has any effect
.I immediately
before a newline character.

Anywhere else in a line, even if only whitespace follows, it prints a
literal slash.

.SS Speed control

Multi-character control codes controlling text speed.

.PP
Whitespace after these codes is ignored; you can cause it to be
treated literally by adding a trailing separator character, i.e.
.BR !sd|
etc.

.PP
If one of these sequences would appear in literal text, it can be
escaped by prefixing it with a single hash character, i.e.
.BR #!sd
etc.

.PP
Due to existing conventions for script layout, these codes are also
valid as standalone commands without a preceding text marker; in this
case they must be the only thing on their line apart from whitespace.

.TP 2
.BI !s NUM
Sets text speed; this is equivalent to the commmand
.IP "" 4
.BI textspeed \ NUM
.IP "" 2
but has a more convenient syntax in cases where the speed must change
within a single line.

.IP "" 2
Lower speeds are faster; 0 means there should be no delay between
characters.

.TP 2
.BI !sd
Resets text speed to the current player-selected default.

.TP 2
.BI !w NUM
Inserts a pause of NUM milliseconds.

It cannot be truncated by clicking, but can be skipped with any of the
normal skip commands.

.TP 2
.BI !d NUM
As
.BR !w ,
but can also be truncated by clicking.

.SS Colour tags

.BI # RRGGBB\fR,
where
.IR RR ", " GG ", and " BB
are each two hex digits, modifies the current text foreground colour
in the obvious way.

A literal hash character can be inserted with
.BR ## .

.SS Formatting tags

All formatting other than text colour is performed with formatting tag
blocks.

These are delimited with tildes; a literal tilde can be inserted with
a double tilde
.RI ( not
.BR #~ ...
that would be consistent.)

Any number of tags can be combined within a single block, optionally
separated with whitespace.

.PP
.B Font selection tags
.PP

The tags in this section, with the exception of
.BR c ,
assume that Ponscripter's eight font slots are assigned according to
the following convention:
.IP "" 2
0 \- text regular
.br
1 \- text italic
.br
2 \- text bold
.br
3 \- text bold italic
.br
4 \- display regular
.br
5 \- display italic 
.br
6 \- display bold
.br
7 \- display bold italic
.PP
If fonts are assigned in any other way, tags such as
.BR b \ and \ i
will not behave as documented.

Font slots are assigned using the
.B h_mapfont
command, which is documented in
.BR ponscr-ext (7)

.TP 2
.BI c N
Selects the font in slot
.IR N .

.TP 2
.BI d
Selects the default style (equivalent to
.BR c0 )

.TP 2
.BI r
Disables italics (default)

.TP 2
.BI i
Toggles italics

.TP 2
.BI t
Disables bold weight

.TP 2
.BI b
Toggles bold weight

.TP 2
.BI f
Selects text face (default)

.TP 2
.BI s
Toggles display face

.PP
.B Text size
.PP

In this section, the
.BR base
size refers to the font size defined for the active window; the
.BR current
size should be self-explanatory.

.TP 2
.BI = N
Set font size to exactly
.I N
pixels (0 restores it to the base font size)

.TP 2
.BI % N
Set font size to
.IR N %
of the base font size

.TP 2
.BI + N
Increase the current font size by
.I N
pixels

.TP 2
.BI - N
Decrease the current font size by
.I N
pixels

.PP
.B Text position

.TP 2
.BI x N
Set the horizontal text output position to
.I N
pixels right of the left margin

.TP 2
.BI y N
Set the vertical text output position to
.I N
pixels down from the top margin

.TP 2
.BI x+ N
Shift the horizontal text output position
.I N
pixels to the right

.TP 2
.BI x- N
Shift the horizontal text output position
.I N
pixels to the left

.TP 2
.BI y+ N
Shift the vertical text output position
.I N
pixels down

.TP 2
.BI y- N
Shift the vertical text output position
.I N
pixels up

.PP
.B Indentation

.TP 2
.BI "n "
Set the indent to the current horizontal position.

New text lines will start from this offset until the end of the
current page.

.TP 2
.BI "u "
Reset the indent to the left margin.

This will only affect
.I subsequent
line breaks; to end an indented section within a page, position this
at the end of the last line of the indented section.

.PP
In addition to these tags, the indent is set automatically when the
first character of a page is an indent character.

The set of indent characters can be configured with the
.B h_indentstr
command (described in
.BR ponscr-ext (7)).
By default it includes opening quotes and em dashes.

.PP
.B Formatting examples
.PP

As an example of the usage of these tags, Narcissu 2's omake mode
displays page headings at the top of each screen with code like
.IP "" 2
.RB ^\fI!s0 ~i\ %120\ x-20\ y-40~ \ Heading ~i\ =0~ \fI!sd
.br
.B br2
120
.PP
Here the !s0 and !sd are the usual NScripter commands.

The first tag block selects italic text, 120% of the regular font
size, and shifts the output position up and to the left.

The second tag block cancels the italic effect and resets the font
size to normal.

.PP
An example of indentation:
.IP "" 2
^**%.Item 1
.br
^Not indented
.br
.RB ^**%. ~n~ Item\ 2
.br
.RB ^Indented ~u~
.br
^Not indented

.SS Ligatures and shortcuts

To assist in typing Unicode scripts with ASCII keyboards, Ponscripter
has the ability to replace sequences of characters with Unicode
symbols.

This facility is also used to implement the hash-escaping of
single-character control codes, and can be used to add ligatures
automatically.

It is only enabled in native scripts; none of this is possible in
legacy mode.

.PP
A shortcut is a mapping of a sequence of characters to a Unicode
codepoint.

As text is rendered, it is checked for known sequences; if one is
found, and the corresponding Unicode character has a glyph in the
current font, then that is substituted.

.PP
A shortcut sequence can be inserted literally by separating the
characters with either a Unicode ZWNJ or a | character, e.g.
.BR `|`
to insert two separate open single quotes.

A literal | can be inserted with ||.

.PP
By default, the following character sequences are defined, in addition
to the hash escapes described above:

.IP "" 2
.BR \`\`
\-> open double quotes
.br
.BR \'\'
\-> close double quotes
.br
.BR \`
\-> open single quote
.br
.BR \'
\-> close single quote / apostrophe

.PP
Additional sequences can be defined by use of the
.BR h_ligate
command: see
.BR ponscr-ext (7).

.SS Variable interpolation

Unlike in vanilla NScripter, merely including the name of a variable
in text does not cause it to be interpolated; this is because frankly
it seems to be more common to want something like
.BR $500
to be literal text representing a sum of money.

Instead, variables will be interpolated if enclosed in braces:
.BR {$foo} ", " {?100[%index]} ,
and so forth.

The variable's sigil must immediately follow the opening angle brace,
and only variables can be interpolated, not arbitrary expressions.

This is not to be confused with NScripter's rather less useful brace
syntax (variable assignments), which is not supported.

.PP
To include a literal sequence of a left brace followed by a sigil
character, use a separator character,
.BR {|% .

.PP
Certain control codes are recognised after variable interpolation,
since they are parsed at a later stage of processing: these are text
controls, speed controls, colour tags, and ligatures/shortcuts.

In particular \- and in contrast to NScripter \- things like
.IP "" 2
.RI ^ !w {%var}
.PP
will be interpreted as a command to wait for however long is specified
in the given variable.

This should be considered an undefined behaviour, and will probably
change in future; rather than rely on it, you should use the
.BR wait
command (and so forth) for variable timings, and in the unlikely event
that you actually intend to print the literal string
.BR !w
followed by the value of
.BR %var ,
you should write
.BR #!w{%var}
to avoid ambiguity.

.PP

Variable interpolations are not expanded recursively.

Likewise, formatting codes are not processed during interpolation;
however, if the string was delimited with ^ rather than \(dq, they
will have been processed when the string was read, and will therefore
work as intended.

That is to say,
.IP "" 2
.B mov
$var, \(dq~b~\(dq
.br
.RI ^foo {$var} bar\e
.br
; prints \(dqfoo~b~bar\(dq
.IP "" 2
.B mov
$var,
.RB ^ ~b~ ^
.br
.RI ^foo {$var} bar\e
.br
.RB ;\ prints\ \(dqfoo bar \(dq

.SH BUGS

This whole syntax may be considered a bug: it is inconvenient,
irregular, and needlessly difficult to parse.

Don't blame me: I didn't design it, I'm just documenting it.

If you want a similar tool with sane syntax, try something like
Ren'Py.

.SH SEE ALSO

.BR ponscripter (7)
-->
  
</refentry>

<?L <!-- ?></reference></book><?L --> ?>
