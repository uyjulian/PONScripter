.TH ponscr-syntax 7 2009-01-19 Ponscripter "Ponscripter manual"
.
.\" This currently doesn't format well with WoMan.
.\" Problems: `.IP "" n', `\(dq'
.
.if n .ad l
.nh
.SH NAME
ponscr-syntax \- description of Ponscripter syntax
.
.SH DESCRIPTION
.
This page documents the syntax of Ponscripter scripts.
.
See
.BR ponscripter (7)
for an overview of other documentation.
.
.PP
Note that this cannot be considered NScripter documentation.
.
NScripter itself is largely unspecified.
.
Ponscripter's implementation is ultimately based on observation and
documentation rather than on reverse-engineering as such: it
inevitably adopts different parsing strategies, and is more liberal in
what it accepts.
.
Not all differences are described below.
.
With this disclaimer out of the way: the documentation.
.
.SS Fundamentals
Scripts are line-based.
.
There are two parsing modes: command mode and text mode.
.
Parsing of each line begins in command mode, and switches to text mode
for the rest of the line if a text command is encountered.
.
.PP
A third mode, `unmarked text', exists for legacy reasons.
.
This mode is similar to text mode, and is entered if an invalid
character is encountered at the start of a command: that is, a number,
a character outside the ASCII range, or anything in the set
.BR [@\e/%?$[(!#,\(dq] .
.
Such lines are valid if they contain
.I only
!-commands; otherwise a warning is issued, and the behaviour is
undefined.
.
.PP
(This mode derives from NScripter, where traditionally there was no
intersection between printable characters and command characters; the
\` text marker was introduced in ONScripter as a means of supporting
English text, and replaced in Ponscripter with ^ to free up \` for
other uses.
.
Since unmarked text serves no useful purpose, and complicates parsing,
it is deprecated and will be removed without notice at some point in
the future.)
.
.PP
The two parsing modes have little in common.  The following sections
discuss command mode; text mode is then treated separately.
.
.SS Context
.
NScripter is a context-sensitive language.
.
Each parameter to a command is parsed differently based on the type of
that parameter.
.
The major types are
.BR string \ and \ integer ,
with labels and barewords being special cases of string parameters.
.
.PP
String expressions do not merely have a different type from integer
expressions, as in other languages: they have a distinct syntax.
.
Some string expressions can be parsed as integer expressions, but then
leave code unparsed that will cause a syntax error when it is reached.
.
It is therefore impossible, in the general case, to parse a line of
code unless it is known in advance what context each parameter is
using.
.
.PP
For example, given the following definitions:
.IP "" 2
.B numalias
foo, 100
.br
.B stralias
foo, ^bar^
.PP
the constant `foo' would have the value 100 in integer context, but
would have the value `bar' in string context.
.
.PP
See the next section for more on constants, and `Expression syntax'
below for details of the syntax accepted in each context.
.
.SS Lexical categories
.
The following broad lexical categories are used in command mode
(parenthesised names are used in syntax descriptions below):
.
.TP 2
.B Comments
are introduced with a semicolon, and last to the end of the line.
.
.TP 2
.BR Barewords \ (\fIbareword\fR)
have the same syntax as identifiers in most programming languages: the
first character must be in the set
.BR [A-Za-z_] ,
and the remainder must be in the set
.BR [A-Za-z0-9_] .
.
.IP "" 2
A bareword at the start of a line, or immediately following a colon,
is assumed to be a command.
.
Otherwise their interpretation is context-sensitive.
.
.IP \(bu
If an alias exists of the desired type (a
.BR numalias " in number context, or a " stralias
in string context) then the bareword acts as a constant, and the value
of the alias is substituted.
.
.IP \(bu
In string context where no stralias exists, the bareword itself is
treated as a string; it will be transformed to lower case and
substituted directly.
.
.IP \(bu
In number context where no numalias exists, a warning is issued and 0 is
substituted.
.
.IP \(bu
Some commands, such as
.BR rmenu ", " ld ", and " systemcall ,
look for barewords directly for certain parameters; in these cases
aliases are not resolved.
.
.TP 2
.BR String\ literals \ (\fIstring_lit\fR)
are formed in two ways.
.
They may be enclosed in regular double quotes, or in pairs of the text
delimiter (^ in native scripts, \` in legacy scripts).
.
The two forms have slightly different semantics.
.
Strings enclosed in text delimiters support
.BR ~ -tags
(described under `text mode' below) to apply text formatting, while
tildes are literal characters in double-quoted strings.
.
.IP "" 2
In ONScripter, and previous versions of Ponscripter, double-quoted
strings had semantics similar to unmarked text \- in particular,
whitespace was ignored.
.
.IR "This is not the case in Ponscripter" ,
and the \(dq^...\(dq quoting format no longer has any special purpose,
though it is still supported for compatibility reasons (it is
equivalent to a double-quoted string).
.
.TP 2
.BR Numeric\ literals \ (\fInum_lit\fR)
are straightforward.
.
Unlike NScripter, which accepts only integer literals, Ponscripter
also understands the C-style
.BI 0x NN
notation for hexadecimal numbers.
.
.TP 2
.BR Label\ literals \ (\fIlabel\fR)
have the general format
.BI * bareword\fR.
.
They are used to represent the target for a jump command
.RB ( goto ", " csel ,
etc) and for the construction of subroutines with commands such as
.BR defsub ", " textgosub ,
etc.
.
.IP "" 2
They also have a special meaning at the start of a line: rather than
being interpreted as command names, label literals declare a label,
i.e. the source code location referenced by jump and
subroutine-construction commands.
.
.IP "" 2
(In NScripter, label literals are a distinct type that can only be
used where a command is expecting a label.
.
ONScripter also accepts them wherever a string is expected:
.IR *foo
means roughly the same thing as
.IR "foo" .)
.
.TP 2
.BR Colour\ literals \ (\fIcolour\fR)
have the general format
.BI # RRGGBB
where
.IR RR ", " GG ", and " BB
are each two hex digits.
.
They are used to represent colours in the obvious way.
.
.IP "" 2
(In NScripter, colour literals are a distinct type that can only be
used where a command is expecting a colour.
.
ONScripter also accepts them wherever a string is expected:
.IR #RRGGBB
means exactly the same thing as
.IR \(dq#RRGGBB\(dq .)
.
.TP 2
.BR Variables " (\fIint_var\fR, \fIstring_var\fR)"
take the form of a sigil followed by either a number, a bareword
(which must have been defined with
.BR numalias ),
or an integer variable (with sigil) for indirect access.
.
The sigils are
.BR %
for integer variables,
.BR ?
for integer arrays, and
.BR $
for string variables.
.
.IP "" 2
Hence 
.BR %200 ", " $foo ", " $%foo ", " ?bar[10][5] .
.IP "" 2
This last example illustrates the subscript syntax for a
multidimensional array.  (See documentation of the
.BR dim
command for details of arrays.)
.
.IP "" 2
Variable syntax is expressed formally in the expression sections
below.
.
.SS Expression syntax
.
.TP 2
.BR Integer\ expressions " (\fIint_expr\fR)"
.\" ScriptHandler::readInt/parseIntExpression/readNextOp/parseInt
are similar to those in other languages.
.
There are two operator precedence levels:
.BR + " and " \-
are low precedence, while
.BR * ", " / ", and " mod
are high precedence.
.
Parentheses and unary minus operate as normal.
.
.IP "" 2
More formally:
.
.IP "" 4
.BR int_expr "  ::="
.IB int_term " \fR| " int_term \ *\fR|\fB/\fR|\fBmod \ int_expr
.br
.BR int_term "  ::="
.IB int_unary " \fR| " int_unary \ +\fR|\fB\- \ int_term
.br
.BR int_unary " ::="
.IR int_paren " | \fB\- " int_paren
.br
.BR int_paren " ::="
.BI "( " int_expr " ) \fR| " int_elt
.br
.BR int_elt "   ::="
.IR num_lit " | " int_var " | " bareword
.br
.BR int_var "   ::="
.BI % int_elt " \fR| " int_array
.br
.BR int_array " ::="
.BI ? "int_elt subscript" \fR+
.br
.BR subscript " ::="
.BI "[ " int_expr " ]"
.br
.BR num_lit "   ::="
.IR [0\-9]+ " | \fB0x" [0-9a-f]+
.br
.BR bareword "  ::="
.IR [a-z_][a-z_0-9]+
.
.TP 2
.BR String\ expressions " (\fIstring_expr\fR)"
.\" ScriptHandler::readStr/parseStr
are simpler.
.
Their grammar is as follows:
.IP "" 4
.BR string_expr " ::="
.IB string_term " | " string_term " + " string_expr
.br
.BR string_term " ::="
.IR file_cond " | " string_elt
.br
.BR file_cond "   ::="
.BI "( " string_term " ) " string_term " " string_term
.br
.BR string_elt "  ::="
.IR string_lit " | " string_var " | " label " | " colour " | " bareword
.br
.BR string_var "  ::="
.BI $ int_elt
.br
.BR label "       ::="
.BI * [a-z_0-9]+
.br
.BR string_lit "  ::="
.BI \(dq [^\(dq]*? \(dq "\fR | " ^ [^^]*? ^
.
.IP "" 2
The only part of the above that should not be obvious, given the
descriptions under `Lexical categories' above, is the
.I file_cond
term.
.
This is only useful when the
.BR filelog
command is in effect.
.
The parenthesised string is interpreted as the name of an image file.
.
If the player has viewed this file, the first of the subsequent terms
is used; otherwise, the second is used.
.
.TP 2
.B Conditional expressions
.
are effectively a special syntax associated with the
.BR if / notif
commands.
.
They are somewhat lacking compared to conditionals in most languages:
in particular, multiple terms may be combined only with an `and'
operator, with no `or' available.
.
.IP "" 2
Either strings or integers may be compared.
.
The ordering of strings is deliberately left undefined; it may change
without warning in the future.
.
However, for any given Ponscripter version, the ordering will be the
same across all platforms and regardless of users' locale settings.
.
.IP "" 2
Several operators accept variant forms:
.BR && \ for \ & ,
.BR = \ for \ == ,
and
.BR <> \ for \ != .
In each case, there is no semantic difference between the two.
.
.IP "" 2
One other type of term is permitted: a function-like
.BR fchk ,
which takes a string, interprets it as the filename of a picture,
and returns true iff that picture has been displayed.
.
.IP "" 2
Formally:
.
.IP "" 4
.BR conditional " ::="
.IR cond_term " | " cond_term " \fB& " conditional
.br
.BR cond_term "   ::="
.IR comp_term " | \fBfchk " string_expr
.br
.BR comp_term "   ::="
.IB expression " ==\fR|\fB!=\fR|\fB>\fR|\fB<\fR|\fB>=\fR|\fB<= " expression
.br
.BR expression "  ::="
.IR int_expr " | " string_expr
.
.SS Command syntax
.
The above lexemes and expressions are combined in a fairly similar way
to BASIC.
.
Commands are interpreted sequentially, one to a line; multiple
commands may be placed on a single line, where required, by separating
them with colons.
.
.PP
There are several forms of command:
.
.IP \(bu
.BR Procedure\ call s
consist of a bareword, normally followed by a parameter list: this is
a comma-separated list of expressions (parentheses are not used).
.
.IP \(bu
.BR Label s
consist of a label literal, which serves as a name for that point in
the script.
.
There is also a form of anonymous label, represented by a single
.B ~
character, which is used by the
.B jumpf
and
.B jumpb
commands.
.
.IP \(bu
.BR Text
commands consist of a text delimiter, which switches the interpreter
into text mode for the remainder of the line; see next section.
.
.SS Text mode
.
As described above, text commands begin with a text marker
.RB ( ^
in native scripts,
.B \`
in legacy scripts).
.
The remainder of the line is then parsed in text mode.
.
.PP
Most characters in text mode represent themselves and are printed
verbatim; this includes the newline at the end of each line, unless
it is explicitly suppressed with
.BR / .
.
It also includes characters with special meanings in command mode,
such as colons and semicolons.
.
However, there are also a fair number of control characters with
special meanings.
.
Since text syntax was not so much designed as gradually accumulated,
there is very little consistency in how these control characters are
chosen, when exactly in the parsing process they are interpreted, and
how they are printed literally.
.
Read on for details.
.
.SS Text control
.
Single characters with special meanings.
.
These characters may all be printed literally by prefixing them with
a single hash character, i.e.
.BR #@ ", " #_ ,
etc.
.
.TP 2
.BR @
Waits for click, then continues printing text as though nothing had
happened.
.
.IP "" 2
(Unlike in many ONScripter builds, the behaviour of
.BR @
is not altered by the definition of a
.BR textgosub
routine.)
.
.TP 2
.BR \e
Waits for a click, then clears text window and begin a new page.
.
.TP 2
.BR _
If a character has the
.BR clickstr
nature, prefixing it with an underscore suppresses that behaviour;
otherwise it does nothing whatsoever.
.
.IP "" 2
.BR clickstr
is evil, so you should never need to use this.
.
.TP 2
.BR /
At the end of a line, ends a text command without beginning a new line
of display text.
.
This control only has any effect
.I immediately
before a newline character.
.
Anywhere else in a line, even if only whitespace follows, it prints a
literal slash.
.
.SS Speed control
.
Multi-character control codes controlling text speed.
.
.PP
Whitespace after these codes is ignored; you can cause it to be
treated literally by adding a trailing separator character, i.e.
.BR !sd|
etc.
.
.PP
If one of these sequences would appear in literal text, it can be
escaped by prefixing it with a single hash character, i.e.
.BR #!sd
etc.
.
.PP
Due to existing conventions for script layout, these codes are also
valid as standalone commands without a preceding text marker; in this
case they must be the only thing on their line apart from whitespace.
.
.TP 2
.BI !s NUM
Sets text speed; this is equivalent to the commmand
.IP "" 4
.BI textspeed \ NUM
.IP "" 2
but has a more convenient syntax in cases where the speed must change
within a single line.
.
.IP "" 2
Lower speeds are faster; 0 means there should be no delay between
characters.
.
.TP 2
.BI !sd
Resets text speed to the current player-selected default.
.
.TP 2
.BI !w NUM
Inserts a pause of NUM milliseconds.
.
It cannot be truncated by clicking, but can be skipped with any of the
normal skip commands.
.
.TP 2
.BI !d NUM
As
.BR !w ,
but can also be truncated by clicking.
.
.SS Colour tags
.
.BI # RRGGBB\fR,
where
.IR RR ", " GG ", and " BB
are each two hex digits, modifies the current text foreground colour
in the obvious way.
.
A literal hash character can be inserted with
.BR ## .
.
.SS Formatting tags
.
All formatting other than text colour is performed with formatting tag
blocks.
.
These are delimited with tildes; a literal tilde can be inserted with
a double tilde
.RI ( not
.BR #~ ...
that would be consistent.)
.
Any number of tags can be combined within a single block, optionally
separated with whitespace.
.
.PP
.B Font selection tags
.PP
.
The tags in this section, with the exception of
.BR c ,
assume that Ponscripter's eight font slots are assigned according to
the following convention:
.IP "" 2
0 \- text regular
.br
1 \- text italic
.br
2 \- text bold
.br
3 \- text bold italic
.br
4 \- display regular
.br
5 \- display italic 
.br
6 \- display bold
.br
7 \- display bold italic
.PP
If fonts are assigned in any other way, tags such as
.BR b \ and \ i
will not behave as documented.
.
Font slots are assigned using the
.B h_mapfont
command, which is documented in
.BR ponscr-ext (7)
.
.TP 2
.BI c N
Selects the font in slot
.IR N .
.
.TP 2
.BI d
Selects the default style (equivalent to
.BR c0 )
.
.TP 2
.BI r
Disables italics (default)
.
.TP 2
.BI i
Toggles italics
.
.TP 2
.BI t
Disables bold weight
.
.TP 2
.BI b
Toggles bold weight
.
.TP 2
.BI f
Selects text face (default)
.
.TP 2
.BI s
Toggles display face
.
.PP
.B Text size
.PP
.
In this section, the
.BR base
size refers to the font size defined for the active window; the
.BR current
size should be self-explanatory.
.
.TP 2
.BI = N
Set font size to exactly
.I N
pixels (0 restores it to the base font size)
.
.TP 2
.BI % N
Set font size to
.IR N %
of the base font size
.
.TP 2
.BI + N
Increase the current font size by
.I N
pixels
.
.TP 2
.BI - N
Decrease the current font size by
.I N
pixels
.
.PP
.B Text position
.
.TP 2
.BI x N
Set the horizontal text output position to
.I N
pixels right of the left margin
.
.TP 2
.BI y N
Set the vertical text output position to
.I N
pixels down from the top margin
.
.TP 2
.BI x+ N
Shift the horizontal text output position
.I N
pixels to the right
.
.TP 2
.BI x- N
Shift the horizontal text output position
.I N
pixels to the left
.
.TP 2
.BI y+ N
Shift the vertical text output position
.I N
pixels down
.
.TP 2
.BI y- N
Shift the vertical text output position
.I N
pixels up
.
.PP
.B Indentation
.
.TP 2
.BI "n "
Set the indent to the current horizontal position.
.
New text lines will start from this offset until the end of the
current page.
.
.TP 2
.BI "u "
Reset the indent to the left margin.
.
This will only affect
.I subsequent
line breaks; to end an indented section within a page, position this
at the end of the last line of the indented section.
.
.PP
In addition to these tags, the indent is set automatically when the
first character of a page is an indent character.
.
The set of indent characters can be configured with the
.B h_indentstr
command (described in
.BR ponscr-ext (7)).
By default it includes opening quotes and em dashes.
.
.PP
.B Formatting examples
.PP
.
As an example of the usage of these tags, Narcissu 2's omake mode
displays page headings at the top of each screen with code like
.IP "" 2
.RB ^\fI!s0 ~i\ %120\ x-20\ y-40~ \ Heading ~i\ =0~ \fI!sd
.br
.B br2
120
.PP
Here the !s0 and !sd are the usual NScripter commands.
.
The first tag block selects italic text, 120% of the regular font
size, and shifts the output position up and to the left.
.
The second tag block cancels the italic effect and resets the font
size to normal.
.
.PP
An example of indentation:
.IP "" 2
^**%.Item 1
.br
^Not indented
.br
.RB ^**%. ~n~ Item\ 2
.br
.RB ^Indented ~u~
.br
^Not indented
.
.SS Ligatures and shortcuts
.
To assist in typing Unicode scripts with ASCII keyboards, Ponscripter
has the ability to replace sequences of characters with Unicode
symbols.
.
This facility is also used to implement the hash-escaping of
single-character control codes, and can be used to add ligatures
automatically.
.
It is only enabled in native scripts; none of this is possible in
legacy mode.
.
.PP
A shortcut is a mapping of a sequence of characters to a Unicode
codepoint.
.
As text is rendered, it is checked for known sequences; if one is
found, and the corresponding Unicode character has a glyph in the
current font, then that is substituted.
.
.PP
A shortcut sequence can be inserted literally by separating the
characters with either a Unicode ZWNJ or a | character, e.g.
.BR `|`
to insert two separate open single quotes.
.
A literal | can be inserted with ||.
.
.PP
By default, the following character sequences are defined, in addition
to the hash escapes described above:
.
.IP "" 2
.BR \`\`
\-> open double quotes
.br
.BR \'\'
\-> close double quotes
.br
.BR \`
\-> open single quote
.br
.BR \'
\-> close single quote / apostrophe
.
.PP
Additional sequences can be defined by use of the
.BR h_ligate
command: see
.BR ponscr-ext (7).
.
.SS Variable interpolation
.
Unlike in vanilla NScripter, merely including the name of a variable
in text does not cause it to be interpolated; this is because frankly
it seems to be more common to want something like
.BR $500
to be literal text representing a sum of money.
.
Instead, variables will be interpolated if enclosed in braces:
.BR {$foo} ", " {?100[%index]} ,
and so forth.
.
The variable's sigil must immediately follow the opening angle brace,
and only variables can be interpolated, not arbitrary expressions.
.
This is not to be confused with NScripter's rather less useful brace
syntax (variable assignments), which is not supported.
.
.PP
To include a literal sequence of a left brace followed by a sigil
character, use a separator character,
.BR {|% .
.
.PP
Certain control codes are recognised after variable interpolation,
since they are parsed at a later stage of processing: these are text
controls, speed controls, colour tags, and ligatures/shortcuts.
.
In particular \- and in contrast to NScripter \- things like
.IP "" 2
.RI ^ !w {%var}
.PP
will be interpreted as a command to wait for however long is specified
in the given variable.
.
This should be considered an undefined behaviour, and will probably
change in future; rather than rely on it, you should use the
.BR wait
command (and so forth) for variable timings, and in the unlikely event
that you actually intend to print the literal string
.BR !w
followed by the value of
.BR %var ,
you should write
.BR #!w{%var}
to avoid ambiguity.
.
.PP
.
Variable interpolations are not expanded recursively.
.
Likewise, formatting codes are not processed during interpolation;
however, if the string was delimited with ^ rather than \(dq, they
will have been processed when the string was read, and will therefore
work as intended.
.
That is to say,
.IP "" 2
.B mov
$var, \(dq~b~\(dq
.br
.RI ^foo {$var} bar\e
.br
; prints \(dqfoo~b~bar\(dq
.IP "" 2
.B mov
$var,
.RB ^ ~b~ ^
.br
.RI ^foo {$var} bar\e
.br
.RB ;\ prints\ \(dqfoo bar \(dq

.SH BUGS
.
This whole syntax may be considered a bug: it is inconvenient,
irregular, and needlessly difficult to parse.
.
Don't blame me: I didn't design it, I'm just documenting it.
.
If you want a similar tool with sane syntax, try something like
Ren'Py.
.
.SH SEE ALSO
.
.BR ponscripter (7)
